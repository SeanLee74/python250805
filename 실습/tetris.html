<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Tetris Game</title>
  <style>
    body {
      background: #222;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 0;
    }
    h1 {
      margin-top: 20px;
    }
    #score {
      margin: 10px 0;
      font-size: 1.2em;
    }
    canvas {
      background: #111;
      box-shadow: 0 0 10px #000;
      margin-bottom: 20px;
      display: block;
    }
    #info {
      color: #aaa;
      font-size: 0.95em;
    }
  </style>
</head>
<body>
  <h1>Tetris</h1>
  <div id="score">Score: 0</div>
  <canvas id="tetris" width="300" height="600"></canvas>
  <div id="info">← → : 이동, ↑ : 회전, ↓ : 빠르게 내리기</div>
  <script>
    // 게임 설정
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 30;
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const scoreElem = document.getElementById('score');
    const colors = [
      null,
      '#0ff', // I
      '#00f', // J
      '#fa0', // L
      '#ff0', // O
      '#0f0', // S
      '#80f', // T
      '#f00'  // Z
    ];

    // 테트로미노 도형
    const tetrominos = [
      [],
      [[1,1,1,1]], // I
      [[1,0,0],[1,1,1]], // J
      [[0,0,1],[1,1,1]], // L
      [[1,1],[1,1]], // O
      [[0,1,1],[1,1,0]], // S
      [[0,1,0],[1,1,1]], // T
      [[1,1,0],[0,1,1]]  // Z
    ];

    // 랜덤 테트로미노 생성
    function randomTetromino() {
      const type = Math.floor(Math.random() * 7) + 1;
      const shape = tetrominos[type].map(row => [...row]);
      return {
        x: Math.floor(COLS / 2) - Math.ceil(shape[0].length / 2),
        y: 0,
        shape,
        type
      };
    }

    // 회전 함수
    function rotate(matrix) {
      return matrix[0].map((_, i) => matrix.map(row => row[i])).reverse();
    }

    // 충돌 체크
    function collide(grid, piece) {
      const {shape, x: px, y: py} = piece;
      for (let y = 0; y < shape.length; ++y) {
        for (let x = 0; x < shape[y].length; ++x) {
          if (shape[y][x]) {
            let gx = px + x, gy = py + y;
            if (gx < 0 || gx >= COLS || gy >= ROWS) return true;
            if (gy >= 0 && grid[gy][gx]) return true;
          }
        }
      }
      return false;
    }

    // 줄 삭제
    function clearRows(grid) {
      let cleared = 0;
      outer: for (let y = ROWS - 1; y >= 0; --y) {
        for (let x = 0; x < COLS; ++x) {
          if (!grid[y][x]) continue outer;
        }
        grid.splice(y, 1);
        grid.unshift(Array(COLS).fill(0));
        ++cleared;
        ++y;
      }
      return cleared;
    }

    // 그리드와 블록 그리기
    function drawGrid(grid, piece) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // 그리드
      for (let y = 0; y < ROWS; ++y) {
        for (let x = 0; x < COLS; ++x) {
          if (grid[y][x]) {
            ctx.fillStyle = colors[grid[y][x]];
            ctx.fillRect(x*BLOCK_SIZE, y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = "#222";
            ctx.strokeRect(x*BLOCK_SIZE, y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }
      // 현재 블록
      if (piece) {
        ctx.save();
        for (let y = 0; y < piece.shape.length; ++y) {
          for (let x = 0; x < piece.shape[y].length; ++x) {
            if (piece.shape[y][x]) {
              ctx.fillStyle = colors[piece.type];
              ctx.fillRect((piece.x + x)*BLOCK_SIZE, (piece.y + y)*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
              ctx.strokeStyle = "#222";
              ctx.strokeRect((piece.x + x)*BLOCK_SIZE, (piece.y + y)*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            }
          }
        }
        ctx.restore();
      }
      // 격자선
      ctx.strokeStyle = "#444";
      for (let x = 0; x <= COLS; ++x)
        ctx.beginPath(), ctx.moveTo(x*BLOCK_SIZE,0), ctx.lineTo(x*BLOCK_SIZE,ROWS*BLOCK_SIZE), ctx.stroke();
      for (let y = 0; y <= ROWS; ++y)
        ctx.beginPath(), ctx.moveTo(0,y*BLOCK_SIZE), ctx.lineTo(COLS*BLOCK_SIZE,y*BLOCK_SIZE), ctx.stroke();
    }

    // 게임 변수
    let grid = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    let current = randomTetromino();
    let next = randomTetromino();
    let score = 0;
    let dropInterval = 500;
    let lastDrop = Date.now();
    let gameOver = false;

    // 게임 루프
    function update() {
      if (gameOver) return;
      let now = Date.now();
      if (now - lastDrop > dropInterval) {
        moveDown();
        lastDrop = now;
      }
      drawGrid(grid, current);
      requestAnimationFrame(update);
    }

    // 블록 내리기
    function moveDown() {
      current.y++;
      if (collide(grid, current)) {
        current.y--;
        merge();
        let cleared = clearRows(grid);
        if (cleared) {
          score += cleared * 100;
          scoreElem.textContent = 'Score: ' + score;
        }
        current = next;
        next = randomTetromino();
        if (collide(grid, current)) {
          gameOver = true;
          scoreElem.textContent += '  -  GAME OVER';
        }
      }
    }

    // 블록 고정
    function merge() {
      const {shape, x: px, y: py, type} = current;
      for (let y = 0; y < shape.length; ++y) {
        for (let x = 0; x < shape[y].length; ++x) {
          if (shape[y][x] && py + y >= 0) {
            grid[py + y][px + x] = type;
          }
        }
      }
    }

    // 키 입력
    document.addEventListener('keydown', e => {
      if (gameOver) return;
      if (e.key === 'ArrowLeft') {
        current.x--;
        if (collide(grid, current)) current.x++;
      } else if (e.key === 'ArrowRight') {
        current.x++;
        if (collide(grid, current)) current.x--;
      } else if (e.key === 'ArrowDown') {
        moveDown();
      } else if (e.key === 'ArrowUp') {
        let old = current.shape;
        current.shape = rotate(current.shape);
        if (collide(grid, current)) {
          // 회전 불가시 원상복구
          current.shape = old;
        }
      }
    });

    // 시작
    update();
  </script>
</body>
</html>